#!/liulab/alynch/projects/benchmarking_python/bin/python

import sys
sys.path.insert(0, '/liulab/alynch/projects/benchmarking/MIRA/')

import anndata
import scanpy as sc
import mira
import numpy as np
import pandas as pd
import os
import dynclipy as dyn

def centered_boxcox_transform(x, a = 'log'):

    if a == 'log' or a == 0:
        return np.log(x) - np.log(x).mean(-1, keepdims = True)

    else:

        assert(isinstance(a, float) and a > 0 and a < 1)
        x = (x**a)/(x**a).mean(-1, keepdims = True)
        return ( x - 1 )/a


def gram_schmidt_basis(n):
    basis = np.zeros((n, n-1))
    for j in range(n-1):
        i = j + 1
        e = np.array([(1/i)]*i + [-1] +
                    [0]*(n-i-1))*np.sqrt(i/(i+1))
        basis[:, j] = e
    return basis

def get_umap_features(topics, a):
    g_matrix = gram_schmidt_basis(topics.shape[-1])
    return centered_boxcox_transform(topics, a = a).dot(g_matrix)

def l2_norm(x):
    return x / np.linalg.norm(x, axis = 1, keepdims = True)

def harmonize_end_cells(data, user_end_cells):
    
    sc.tl.leiden(data, resolution=0.6)
    mira_end_cells = mira.time.find_terminal_cells(data, seed = 0, threshold=1e-2)
    
    def remove_self_cycles(cell_ids, cluster_ids, pseudotimes):

        cell_cluster_dict = dict(zip(cell_ids, cluster_ids))

        no_cycle_dict = {}
        for term_cluster in set(cluster_ids):
            in_cluster_cells = [(cell_id, pseudotime) for cell_id, pseudotime in zip(cell_ids, pseudotimes) if cell_cluster_dict[cell_id] == term_cluster]

            max_time_cell = sorted(in_cluster_cells, key = lambda x : x[1])[-1][0]
            no_cycle_dict[cell_cluster_dict[max_time_cell]] = max_time_cell

        return no_cycle_dict

    user_end_cells = remove_self_cycles(
            user_end_cells, 
            data.obs.loc[user_end_cells, 'leiden'].values, 
            data[user_end_cells].obs_vector('mira_pseudotime')
        )

    
    mira_end_cells = remove_self_cycles(
            mira_end_cells, 
            data.obs.loc[mira_end_cells, 'leiden'].values, 
            data[mira_end_cells].obs_vector('mira_pseudotime')
                                    )

    end_cells = [
        end_cell #mira_end_cells[cluster] if cluster in mira_end_cells else end_cell
        for cluster, end_cell in user_end_cells.items()
    ]
    
    return end_cells


def process_dimred(data, 
    are_topic_compositions = True, 
    use_rep = 'joint',
    box_cox = 0.5):

    if are_topic_compositions:

        topics = data.obsm['dimred']
        divider_col = np.argwhere(np.isclose(topics, 0).all(0))[0,0]

        if use_rep == 'joint' or use_rep == 'joint_constrained':
            if divider_col == 0 or divider_col == topics.shape[-1]-1:
                raise ValueError('User wanted to use "joint" representation, but only one representation was given')

            rep1, rep2 = topics[:, :divider_col], topics[:,divider_col+1:]

            if use_rep == 'joint':
                data.obsm['embedding_features'] = np.hstack([
                    get_umap_features(rep1, box_cox), 
                    get_umap_features(rep2, box_cox)]
                )
            else:
                data.obsm['embedding_features'] = np.hstack([
                    l2_norm(get_umap_features(rep1, box_cox)), 
                    l2_norm(get_umap_features(rep2, box_cox))]
                )

        elif use_rep == 'RNA':
            data.obsm['embedding_features'] = get_umap_features(topics[:, :divider_col], box_cox)
        elif use_rep == 'ATAC':
            data.obsm['embedding_features'] = get_umap_features(topics[:, divider_col+1:], box_cox)
        else:
            raise ValueError('Representation {} is unknown.'.format(use_rep))

        #print(data.obsm['embedding_features'], data.obsm['embedding_features'].shape, data.obs_names)

    else:
        data.obsm['embedding_features'] = data.obsm['dimred']


def run_pseudotime(data, start_cell, end_cells,
    threshold = 0.58, n_neighbors = 30, ka = 10, metric = 'manhattan'):

    sc.pp.neighbors(data, use_rep='embedding_features', metric=metric,
        n_neighbors=n_neighbors)

    sc.tl.umap(data, min_dist = 0.1, negative_sample_rate=1)

    mira.time.get_connected_components(data, key = 'connectivities')
    mira.time.get_transport_map(data, diffmap_distances_key='distances',
                            diffmap_coordinates_key= 'embedding_features',
                                start_cell = start_cell, ka = ka)
    
    end_cells = harmonize_end_cells(data, end_cells)

    mira.time.get_branch_probabilities(data, 
                terminal_cells={str(t) : t for t in end_cells}
        )

    mira.time.get_tree_structure(data, threshold = threshold)


def format_results(adata):

    cell_ids = adata.obs_names.values.astype(str)
    tree_matrix = adata.uns['connectivities_tree'][:-1,:-1]
    branch_names = adata.uns['tree_state_names'][:-1]
    branch_tips = adata.obs.groupby('tree_states')['mira_pseudotime'].max()

    try:
        branch_start_time = dict(zip(branch_names, tree_matrix.max(0)))
        branch_end_time = {
            state : branch_tips[state] if end_time == 0 else end_time
            for state, end_time in zip(branch_names, tree_matrix.max(-1))
        }

        def progress(state, time):
            return np.clip(
                (time - branch_start_time[state])/(branch_end_time[state] - branch_start_time[state]),
                a_min = 0, a_max = 1.
            )

        percentage = np.array(
            [progress(state, time) 
            for state, time in zip(adata.obs_vector('tree_states'), adata.obs_vector('mira_pseudotime'))]
        )
    except KeyError:
        min_time, max_time = adata.obs.mira_pseudotime.values.min(), adata.obs.mira_pseudotime.values.max()
        percentage = (adata.obs.mira_pseudotime.values - min_time)/(max_time - min_time)

    branch_progressions = pd.DataFrame(
        {
            'cell_id' : cell_ids, 
            'branch_id' : adata.obs.tree_states.values,
            'percentage' : percentage
        }
    )

    branch_names =  adata.uns['tree_state_names'][:-1]
    branches_df = pd.DataFrame(
        {'branch_id' : branch_names, 
        'directed' : [True]*len(branch_names), 
        'length' : [1]*len(branch_names)}
    )

    edges = (
                pd.DataFrame(
                    tree_matrix, index =branch_names,
                    columns = branch_names
                ) > 0
            ).melt(
                ignore_index = False, 
                var_name = 'to', 
                value_name = 'has_edge'
            ).reset_index().rename(columns = {'index' : 'from'})

    edges = edges[edges.has_edge].drop(columns = 'has_edge')

    dimred = pd.DataFrame(adata.obsm['X_umap'])
    dimred['cell_id'] = cell_ids

    dyn.wrap_data(cell_ids = cell_ids)\
    .add_dimred(dimred)\
    .add_grouping(
        pd.DataFrame(
            {
                'group_id' : adata.obs.tree_states.values.astype(str), 
                'cell_id' : cell_ids
            }))\
    .add_branch_trajectory(
        branch_network = edges,
        branches = branches_df,
        branch_progressions = branch_progressions)\
    .write_output(dataset['output'])


def main(
    adata,
    start_cell,
    end_cells,
    threshold = 0.58,
    n_neighbors = 15,
    metric = 'manhattan',
    are_topic_compositions = True,
    box_cox = 0.5,
    use_rep = 'joint',
):

    process_dimred(adata, 
        are_topic_compositions = are_topic_compositions, 
        use_rep = use_rep,
        box_cox = box_cox)

    run_pseudotime(adata, start_cell, end_cells, metric = metric,
            threshold = threshold, n_neighbors = n_neighbors)

    format_results(adata)


if __name__ == "__main__":

    dataset = dyn.main(definition_location=\
        '/liulab/alynch/projects/benchmarking/frankencell-dynverse/frankencell/methods/mira/definition.yaml')

    params = dataset['parameters']
    priors = dataset['priors']
    rna_counts = dataset['counts']
    N = len(rna_counts)

    dimred = np.array(dataset['priors']['dimred']).reshape((-1, N)).T

    adata = anndata.AnnData(
        obs = pd.DataFrame(index = rna_counts.index.values), obsm = {'dimred' : dimred}
    )

    main(
        adata,
        priors['start_id'],
        priors['end_id'],
        threshold = params['treshold'],
        n_neighbors = params['n_neighbors'],
        metric = params['metric'],
        are_topic_compositions = params['are_topic_compositions'],
        box_cox = params['box_cox'],
        use_rep = params['use_rep']
    )
